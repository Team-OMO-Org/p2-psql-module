-- 1. Total revenue generated by each product.
SELECT p.product_name, SUM(oi.quantity * p.price) AS total_revenue
FROM order_items oi
JOIN products p ON oi.product_id = p.product_id
GROUP BY p.product_name
ORDER BY total_revenue DESC;

-- 2. Customers who placed the most orders.
SELECT c.customer_id, c.first_name, c.last_name, COUNT(o.order_id) AS total_orders
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.first_name, c.last_name
ORDER BY total_orders DESC
LIMIT 10;

-- 3. Average order value for each month.
SELECT EXTRACT(MONTH FROM order_date) AS order_month, ROUND(AVG(total_amount),2) AS avg_order_value
FROM orders
GROUP BY order_month
ORDER BY order_month;

-- 4. Top-selling categories.
SELECT cat.category_name, SUM(oi.quantity) AS total_sold
FROM order_items oi
JOIN products p ON oi.product_id = p.product_id
JOIN categories cat ON p.category_id = cat.category_id
GROUP BY cat.category_name
ORDER BY total_sold DESC;

-- 5. Most popular products in each category.
SELECT cat.category_name, p.product_name, SUM(oi.quantity) AS total_sold
FROM categories cat
JOIN products p ON cat.category_id = p.category_id
JOIN order_items oi ON p.product_id = oi.product_id
GROUP BY cat.category_name, p.product_name
ORDER BY cat.category_name, total_sold DESC;

-- 6. Total quantity of products sold per day.
SELECT order_date, SUM(oi.quantity) AS total_quantity
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY order_date
ORDER BY order_date;

-- 7. Customers who registered but never placed an order.
SELECT c.customer_id, c.first_name, c.last_name
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_id IS NULL;

-- 8. Orders that were cancelled and their total value.
SELECT o.order_id, SUM(oi.quantity * p.price) AS cancelled_value
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id
WHERE o.status = 'Cancelled'
GROUP BY o.order_id;

-- 9. Total number of products sold by category.
SELECT c.category_name, COUNT(oi.product_id) AS total_products_sold
FROM order_items oi
JOIN products p ON oi.product_id = p.product_id
JOIN categories c ON p.category_id = c.category_id
GROUP BY c.category_name;

-- 10. Revenue lost due to cancelled orders.
SELECT SUM(oi.quantity * p.price) AS total_lost_revenue
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id
WHERE o.status = 'Cancelled';

-- 11. Most valuable customers by total spending.
SELECT c.customer_id, c.first_name, c.last_name, SUM(o.total_amount) AS total_spent
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.first_name, c.last_name
ORDER BY total_spent DESC;

-- 12. Products never added to a shopping cart.
SELECT product_name
FROM products p
WHERE NOT EXISTS (
    SELECT 1
    FROM shopping_cart_items sci
    WHERE sci.product_id = p.product_id
);

-- 13. Percentage of orders shipped versus total orders.
SELECT 
    CAST((COUNT(*) FILTER (WHERE status = 'Shipped') * 100.0 / COUNT(*)) AS INT) AS shipped_percentage
FROM 
    orders;

-- 14. Top 3 products in terms of revenue by category.
WITH RevenueByCategory AS (
    SELECT cat.category_id, cat.category_name, p.product_id, p.product_name, SUM(oi.quantity * p.price) AS revenue,
           RANK() OVER (PARTITION BY cat.category_id ORDER BY SUM(oi.quantity * p.price) DESC) AS rank
    FROM categories cat
    JOIN products p ON cat.category_id = p.category_id
    JOIN order_items oi ON p.product_id = oi.product_id
    GROUP BY cat.category_id, cat.category_name, p.product_id, p.product_name
)
SELECT *
FROM RevenueByCategory
WHERE rank <= 3;

-- 15. Customers who have purchased products from every category.
SELECT c.customer_id, c.first_name, c.last_name
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id
JOIN categories cat ON p.category_id = cat.category_id
GROUP BY c.customer_id, c.first_name, c.last_name
HAVING COUNT(DISTINCT cat.category_id) = (SELECT COUNT(*) FROM categories);

-- 16. Average quantity of items per order.
SELECT AVG(item_count) AS avg_items_per_order
FROM (
    SELECT SUM(quantity) AS item_count
    FROM order_items
    GROUP BY order_id
) AS order_totals;


-- 17. Distribution of product prices by category.
SELECT c.category_name, MIN(p.price) AS min_price, MAX(p.price) AS max_price, AVG(p.price) AS avg_price
FROM products p
JOIN categories c ON p.category_id = c.category_id
GROUP BY c.category_name
ORDER BY c.category_name;

-- 18. Customers who purchased the most expensive product.
WITH MostExpensiveProduct AS (
    SELECT product_id, MAX(price) AS max_price
    FROM products
    GROUP BY product_id
)
SELECT c.customer_id, c.first_name, c.last_name
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN order_items oi ON o.order_id = oi.order_id
JOIN MostExpensiveProduct mep ON oi.product_id = mep.product_id
GROUP BY c.customer_id, c.first_name, c.last_name;

-- 20. Rolling back a transaction if an order exceeds stock.
DO $$
    DECLARE
        new_order_id INT;
    BEGIN
        -- Start the transaction
        BEGIN
            -- Insert into orders and get the new order_id
            INSERT INTO orders (customer_id, order_date, status, total_amount)
            VALUES (1, NOW(), 'Pending', 100.00)
            RETURNING order_id INTO new_order_id;

            -- Insert into order_items using the new order_id
            INSERT INTO order_items (order_id, product_id, quantity)
            VALUES (new_order_id, 1, 10);

            -- Check stock and rollback if insufficient
            IF (SELECT stock_quantity FROM products WHERE product_id = 1) < 10 THEN
                ROLLBACK;
                RAISE EXCEPTION 'Insufficient stock';
            ELSE
                COMMIT;
            END IF;
        END;
    END $$;

-- 21. CREATE VIEW order_details
CREATE VIEW order_details AS
SELECT
    o.order_id,
    o.order_date,
    o.status,
    c.first_name || ' ' || c.last_name AS customer_name,
    p.product_name,
    oi.quantity,
    (oi.quantity * p.price) AS line_total,
    o.total_amount AS order_total
FROM
    orders o
JOIN
    customers c ON o.customer_id = c.customer_id
JOIN
    order_items oi ON o.order_id = oi.order_id
JOIN
    products p ON oi.product_id = p.product_id;

-- 22. Orders by Status and Total Revenue using View order_details
SELECT
    status,
    COUNT(order_id) AS total_orders,
    SUM(order_total) AS total_revenue
FROM
    order_details
GROUP BY
    status
ORDER BY
    total_orders DESC;

-- 23. Create the trigger trigger_update_stock_and_total
CREATE OR REPLACE FUNCTION update_stock_and_order_total() RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'DELETE') THEN
        -- Add stock back when an order item is removed
        UPDATE products
        SET stock_quantity = stock_quantity + OLD.quantity
        WHERE product_id = OLD.product_id;

        -- Update the total amount in the orders table
        UPDATE orders
        SET total_amount = total_amount - (OLD.quantity * (SELECT price FROM products WHERE product_id = OLD.product_id))
        WHERE order_id = OLD.order_id;

    ELSE
        -- Deduct stock when a new order item is added
        UPDATE products
        SET stock_quantity = stock_quantity - NEW.quantity
        WHERE product_id = NEW.product_id;

        -- Ensure stock does not fall below zero
        IF (SELECT stock_quantity FROM products WHERE product_id = NEW.product_id) < 0 THEN
            RAISE EXCEPTION 'Insufficient stock for product_id: %', NEW.product_id;
        END IF;

        -- Update the total amount in the orders table
        UPDATE orders
        SET total_amount = total_amount + (NEW.quantity * (SELECT price FROM products WHERE product_id = NEW.product_id))
        WHERE order_id = NEW.order_id;

    END IF;
END;
$$ LANGUAGE plpgsql;

-- Attach the trigger to the order_items table
CREATE TRIGGER trigger_update_stock_and_total
    AFTER INSERT OR UPDATE OR DELETE ON order_items
    FOR EACH ROW
EXECUTE FUNCTION update_stock_and_order_total();

-- 24. Create the trigger trigger_prevent_category_deletion
CREATE OR REPLACE FUNCTION prevent_category_deletion() RETURNS TRIGGER AS $$
BEGIN
    -- Check if there are any products associated with the category to be deleted
    IF EXISTS (SELECT 1 FROM products WHERE category_id = OLD.category_id) THEN
        -- Raise an exception if there are products associated with the category
        RAISE EXCEPTION 'Cannot delete category % as it is still associated with products', OLD.category_id;
    END IF;

    -- Return OLD to proceed with the deletion
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- Attach the trigger to the categories table
CREATE TRIGGER trigger_prevent_category_deletion
    BEFORE DELETE ON categories
    FOR EACH ROW
EXECUTE FUNCTION prevent_category_deletion();





